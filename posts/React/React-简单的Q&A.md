### React: 什么是虚拟DOM?
- 虚拟DOM 是 真实DOM在内存中的表示, UI的表示形式保存在内存中, 并与实际的DOM同步. 这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤,整个过程被称为`调和`

### 类组件和函数组件的区别
- 类组件可以使用 state 和 生命周期钩子
- 函数组件只是接收`props`渲染到页面, 也就是无状态组件, 哑组件/展示组件
- 函数组件和类组件的主要区别是性能, 使用类组件使用的时候要实例化, 而函数组件直接执行函数获取返回结果即可. 函数组件没有`this`, 没有`生命周期钩子函数`, 没有`state`

### React中 refs
- `refs`提供一种访问在`render`方法中创建的`DOM`节点或者`React`元素的方法, 在电型的数据流中,`props`是父子组件交互的唯一方式,想要修改子组件, 需要使用的新的`props`重新渲染.在某些特殊的情况下,可以使用`refs`强制修改子组件


### state 和 props 的区别
- `state` 是组件自己管理数据, 控制自己的状态, 可变
- `props` 是外部传入的数据参数, 不可变
- 没有 `state` 的组件叫做 无状态组件, 有 `state` 的叫做有状态组件
- 多用 `props`, 少用 `state`

### 在构造函数调用 super 并将 props 作为参数传入的作用是什么
- 在调用`super()`方法之前, 子类构造函数无法使用 `this` 引用, 将`props`作为参数传递给`super()`调用的原因就是在子组件的构造函数中能够通过`this.props`来获取传入的`props`
- `props`的行为只有在构造函数中是不同的, 在构造函数之外是一致的.  [React: constructor中的super](https://github.com/leslie1943/blog/issues/75).

### 为什么不直接更新 state
- 如果视图直接更新 `state` 则不会重新渲染组件
- 需要使用`setState()`方法来更新 `state`, 组件通过重新渲染来响应.

### 什么是 React hooks
- React 16.8中的添加的内容. 允许在不编写类组件的情况下使用`state`和其他`react`特性,


### 使用 React hooks 好处
- `Hooks`通常支持提取和重用跨多个组件通用的有状态逻辑, 而无需承担类组件的性能问题. hooks 可以操作函数组件的状态
- Hooks 在类中不起作用, 通过使用它们, 可以完全避免使用生命周期方法, 使用 useEffect

### 为什么类方法需要绑定到类实例?
- 在`JS`中, `this`的值会根据当前上下文变化. 在`React`类组件方法中. 开发人员通过希望`this`引用组件的当前实例, 因此有必要将这些方法绑定到实例,在构造函数中完成


### React fiber
- Fiber 是 React 16 中新的协调引起和重新实现核心算法. 它的主要目标是支持虚拟DOM的增量渲染. `React Fiber`为不同类型的更新分配渲染优先级, 将渲染工作分成一个个小的纤维, 并分散到多个帧中


### 当调用setState时，React render 是如何工作的?
- 步骤-1: `虚拟DOM`渲染, 当`render`方法被调用时, 它返回也给新的组件组件的`虚拟DOM`结构. 当调用`setState()`时, `render`会被再次调用, 默认情况下`shouldComponentUpdate`总是返回`true`, 所以默认情况下`React`是没有优化的
- 步骤-2: `原生DOM`渲染, React只会在虚拟DOM中修改真实DOM节点, 而且修改的次数非常少- 