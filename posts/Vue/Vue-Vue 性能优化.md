### Vue: Vue 性能优化
- `Vue` 框架通过数据双向绑定和虚拟 `DOM` 技术, 帮我们处理了前端开发中最脏最累的 `DOM` 操作部分,  我们不再需要去考虑如何操作 `DOM` 以及如何最高效地操作 `DOM` , 但 `Vue` 项目中仍然存在项目首屏优化、`Webpack` 编译配置优化等问题, 所以我们仍然需要去关注 `Vue` 项目性能方面的优化, 使项目具有更高效的性能、更好的用户体验


### 代码层面的优化
1. v-if 和 v-show 区分使用场景
2. computed 和 watch 区分使用场景
3. v-for 遍历必须为 item 添加 key, 且避免同时使用 v-if
4. 长列表的性能优化
```bash
# Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。
```
5. 事件的销毁
```bash
# Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露
```
6. 图片资源懒加载
```bash
# 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件
```
7. 路由懒加载
8. 第三方插件的按需引入
9. 优化无限列表性能
10. 服务端渲染 SSR or 预渲染


### Webpack 层面的优化
1. Webpack 对图片进行压缩
```bash
# 在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片

# 1. 安装 image-webpack-loader
# 2. {
#       test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
#       use:[
#           {
#               loader: 'url-loader',
#               options: {
#                   limit: 10000,
#                   name: utils.assetsPath('img/[name].[hash:7].[ext]')
#               }
#           },
#           {
#               loader: 'image-webpack-loader',
#               options: {
#               bypassOnDebug: true,
#           }
#       }]
# }
```
2. 减少 ES6 转为 ES5 的冗余代码
3. 提取公共代码
4. 模板预编译
5. 提取组件的 CSS
6. 优化 SourceMap
7. 构建结果输出分析
8. Vue 项目的编译优化


### 基础的 Web 技术优化
1. 开启 `gzip` 压缩
2. 合理使用浏览器缓存
3. CDN的使用
```bash
# 浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率
```