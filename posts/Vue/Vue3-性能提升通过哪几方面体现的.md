## Vue3: Vue3性能提升通过哪几方面体现的

### 💛 1 - 响应式系统提升
- `Vue2` 在初始化的时候, 对 `data` 中的每个使用 `defineProperty` 调用 `getter` / `setter`使之变为响应式对象, 如果属性值为对象, 还会递归调用`defineProperty`使之变为响应式对象
- `Vue3` 使用 `Proxy` 对象重写响应式, `Proxy`的性能本来就比`defineProperty`好, `Proxy`可以拦截属性的访问, 赋值, 删除 等操作, 不需要初始化的时候遍历所有属性, 另外多层属性嵌套的时候, 只有访问某个属性的时候, 才会递归处理下一级的属性.

- ✅ 可以监听: 动态新增的属性
- ✅ 可以监听: 删除的属性
- ✅ 可以监听: 数组的索引和`length`属性

### 💛 2 - 编译优化
1. 优化编译和重写虚拟dom, 让首次渲染和更新dom性能有更大的提升 
- `Vue2` 通过标记静态根节点优化 `diff` 算法. 
- `Vue3` 标记和提升所有静态根节点, `diff` 的时候只比较动态节点内容
2. `Fragments`: 模板里面不用创建唯一根节点,可以直接放统计标签和文本内容
3. 静态提升(`hoistStatic`):当使用 `hoistStatic` 时,所有静态的节点都被提升到 `render` 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点,随着每次的渲染被不停的复用.
-  `Patch flag`: 在动态标签末尾加上对应的标记, 只有带`patchFlag`的节点才被认为是动态的元素, 会被追踪属性的修改, 能快速的找到动态节点,而不用逐个逐层遍历, 提高虚拟DOMd diff 的
-  缓存事件处理函数 `cacheHandler`: 避免每次触发都要重写生成全新的`function`去更新之前的函数
-  `Tree-shaking`: 通过摇树优化核心库体积,减少不必要的代码

### 💛 3 - 源码体积的优化
- Vue3 移除了一些不常用的 api, 如 `inline-template`, `filter`等, 使用 `tree-shaking`
