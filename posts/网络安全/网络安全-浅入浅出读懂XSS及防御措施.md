### 🚀🚀 网络安全: 浅入浅出读懂XSS及防御措施
- Web攻击(WebAttack)是针对用户上网行为或网站服务器等设备进行攻击的行为,如植入恶意代码, 修改网站权限, 获取网站用户隐私信息等等
- Web应用程序的安全性是任何基于Web业务的重要组成部分
- 确保Web应用程序安全十分重要, 即使是代码中很小的 bug 也有可能导致隐私信息被泄露
- 站点安全就是为保护站点不受未授权的访问, 使用, 修改和破坏而采取的行为或实践
- 我们常见的Web攻击方式有
1. XSS(Cross Site Scripting) 跨站脚本攻击
2. CSRF(Cross-site request forgery) 跨站请求伪造
3. SQL注入攻击

### 🚀🚀 XSS
- 跨站脚本攻击, 允许攻击者将恶意代码植入到提供给其他用户使用的页面中
- XSS 涉及到三方: `攻击者`,`客户端`,`Web应用`
- XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息.一旦获取到合法用户的信息后,攻击者甚至可以假冒合法用户与网站进行交互
- 举个例子
```html
<!-- 一个搜索页面, 根据url 参数决定关键词的内容 -->
<input type="text" value="<%= getParameter("keyword") %>">
<button>搜索</button>
<div>
您搜索的关键词是:<%= getParameter("keyword") %>
</div>
<!-- 这里看似并没有问题,但是如果不按套路出牌呢? -->
<!-- 用户输入"><script>alert('XSS');</script>,拼接到 HTML 中返回给浏览器. 形成了如下的 HTML: -->

<input type="text" value=""><script>alert('XSS');</script>">
<button>搜索</button>
<div>
  您搜索的关键词是:"><script>alert('XSS');</script>
</div>

<!-- 浏览器无法分辨出 <script>alert('XSS');</script> 是恶意代码,因而将其执行,试想一下,如果是获取cookie发送对黑客服务器呢? -->
```

### 🚀🚀 XSS 分类
1. 存储型 XSS
```bash
# 1. 攻击者将恶意代码提交到目标网站的数据库中
# 2. 用户打开目标网站时, 网站服务端将恶意代码从数据库中取出, 拼接在 HTML 中返回给浏览器
# 3. 用户浏览器接收到响应后解析执行, 混在其中的恶意代码也被执行
# 4. 恶意代码执行后可能的操作: 窃取用户数据并发送到攻击者的网站, 或者冒充用户的行为, 调用目标网站接口执行攻击者指定的操作.
# 5. 这种攻击常见于带有用户保存数据的网站功能,如论坛发帖, 商品评论, 用户私信等
```
2. 反射型 XSS
```bash
# 1. 攻击者构造出特殊的URL, 其中包含恶意代码
# 2. 用户打开带着恶意代码的URL时, 网站服务端将恶意代码从 URL 中取出. 拼接在 HTML 中返回给浏览器
# 3. 用户浏览器接收到响应后解析执行, 混在其中的恶意代码也被执行
# 4. 恶意代码窃取用户数据并发送到攻击者的网站, 或者冒充用户的行为, 调用目标网站接口执行攻击者指定的操作
# 🎃🎃 对比 `反射型XSS` 跟 `存储型XSS` 的区别是: `存储型XSS` 的恶意代码存放在数据库中, `反射型XSS` 的恶意代码存放在URL中, `反射型XSS`漏洞常见于URL传递参数的功能, 如网站搜索, 跳转等, 由于需要用户主动打开恶意的URL才能生效, 攻击者往往会结合多种手段诱导用户点击. `POST` 的内容也可以触发 `反射型XSS`, 只不过其触发条件比较苛刻(需要构造表单提交页面, 并引导用户点击), 所以非常少见.
```
3. DOM型
```bash
# 1. 攻击者构造特殊的URL,其中包含恶意代码
# 2. 用户打开带着恶意代码的URL
# 3. 用户浏览器收到响应后解析执行, 前端JS取出URL中的恶意代码并执行
# 4. 恶意代码窃取用户数据并发送到攻击者的网站, 或者冒充用户的行为,调用目标网站接口执行攻击者指定的操作
# 🎃🎃 DOM型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中, 取出和执行恶意代码由浏览器端完成, 属于前端 JavaScript 自身的安全漏洞, 而其他两种 XSS 都属于服务端的安全漏洞
```

### 🚀🚀 XSS 预防
- XSS攻击的两大要素
1. 攻击者提交恶意代码
2. 浏览器执行恶意代码
- 针对第一个要素, 我们在用户输入的过程中, 过滤掉用户输入的恶劣代码, 然后提交给后端, 但是如果攻击者绕开前端请求, 直接构造请求就不能预防了
- 而如果在后端写入数据库前, 对输入进行过滤, 然后把内容给前端, 但是这个内容在不同地方就会有不同显示,  例如:
```bash
# 一个正常的用户输入了 5 < 7 这个内容, 在写入数据库前, 被转义, 变成了 5 < 7
# 在客户端中, 一旦经过了 escapeHTML(), 客户端显示的内容就变成了乱码( 5 &lt; 7 )
# 在前端中, 不同的位置所需的编码也不同. 
# 当 5 < 7 作为 HTML 拼接页面时, 可以正常显示：
# <div title="comment">5 &lt; 7</div>
# 当 5 < 7 通过 Ajax 返回, 然后赋值给 JavaScript 的变量时, 前端得到的字符串就是转义后的字符. 这个内容不能直接用于 Vue 等模板的展示, 也不能直接用于内容长度计算. 不能用于标题, alert 等
# 可以看到, 过滤并非可靠的, 下面就要通过防止浏览器执行恶意代码：
```
- 在使用 `.innerHTML`, `.outerHTML`, `document.write()` 时要特别小心, 不要把不可信的数据作为 `HTML` 插到页面上, 而应尽量使用 `.textContent`, `.setAttribute()` 等
- 如果用 `Vue/React` 技术栈, 并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能, 就在前端 `render` 阶段避免 `innerHTML`, `outerHTML` 的 `XSS` 隐患
- `DOM` 中的内联事件监听器, 如 `location`, `onclick`, `onerror`, `onload`, `onmouseover` 等, <a> 标签的 `href` 属性, `JavaScript` 的 `eval()`, `setTimeout()`, `setInterval()` 等, 都能把字符串作为代码运行. 如果不可信的数据拼接到字符串中传递给这些 `API`, 很容易产生安全隐患, 请务必避免
```html
<!-- 链接内包含恶意代码 -->
<a href="UNTRUSTED">1</a>

<script>
// setTimeout()/setInterval() 中调用恶意代码
setTimeout("UNTRUSTED")
setInterval("UNTRUSTED")

// location 调用恶意代码
location.href = 'UNTRUSTED'

// eval() 中调用恶意代码
eval("UNTRUSTED")
```

### 其他链接
[网络安全: 跨站攻击脚本-XSS](https://github.com/leslie1943/blog/issues/35)
